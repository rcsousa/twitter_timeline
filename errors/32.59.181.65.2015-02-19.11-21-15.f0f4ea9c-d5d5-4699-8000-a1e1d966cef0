(dp1
S'output'
p2
S"<class 'socket.error'> [Errno 111] Connection refused"
p3
sS'layer'
p4
S'/var/www/web2py/applications/twitkiller/controllers/default.py'
p5
sS'code'
p6
S'# -*- coding: utf-8 -*-\n# this file is released under public domain and you can use without limitations\n\n#########################################################################\n## This is a sample controller\n## - index is the default action of any application\n## - user is required for authentication and authorization\n## - download is for downloading files uploaded in the db (does streaming)\n## - api is an example of Hypermedia API support and access control\n#########################################################################\n\ndef index():\n    """\n    example action using the internationalization operator T and flash\n    rendered by views/default/index.html or views/generic.html\n\n    if you need a simple wiki simply replace the two lines below with:\n    return auth.wiki()\n    """\n\n    return dict()\n\n@auth.requires_login()\ndef post():\n    from tweet_tasks import save_post, update_timeline, populate_index\n    import uuid\n    form=SQLFORM(db.tweet,fields=[\'post\'],formstyle=\'bootstrap\')\n    form.vars.tweet_id = uuid.uuid1()\n    form.vars.user_id=auth.user_id\n    form.vars.created_on=request.now\n    if form.validate(): # vai ser o insert\n        response.flash=form.vars.created_on\n        save_post.delay(form.vars.tweet_id,form.vars.user_id,form.vars.post,form.vars.created_on)\n        update_timeline.apply_async((form.vars.tweet_id,form.vars.user_id),countdown=2)\n        populate_index.apply_async((form.vars.user_id,form.vars.post,form.vars.created_on),countdown=5)\n\n    return dict(form=form)\n\n@auth.requires_login()\ndef timeline():\n    try:\n        import memcache, redis\n        from tweet_tasks import recreate_timeline, recreate_memcache\n        rd=redis.Redis(\'localhost\')\n        mc = memcache.Client([\'localhost:11211\'], debug=1)\n        posts=rd.lrange(\'%s\' %auth.user_id, \'0\', \'-1\')\n        if posts:\n            cached_posts = []\n            post_uid = []\n            post_created_on = []\n            for p in posts:\n                cp = mc.get(\'%s\' %p.split(\';\')[0])\n                if not cp:\n                    result = recreate_memcache.delay(auth.user_id)\n                    list = result.get()\n                    return dict(list=list)\n                else:\n                    cached_posts.append(mc.get(\'%s\' %p.split(\';\')[0]))\n                    post_uid.append(p.split(\';\')[1])\n                    post_created_on.append(p.split(\';\')[2])\n            return dict(cached_posts=zip(cached_posts,post_uid,post_created_on))\n        else:\n            cached_posts = []\n            post_uid = []\n            post_created_on = []\n            result = recreate_timeline.delay(auth.user_id)\n            posts = result.get()\n            for p in posts:\n                cached_posts.append(mc.get(\'%s\' %p.split(\';\')[0]))\n                post_uid.append(p.split(\';\')[1])\n                post_created_on.append(p.split(\';\')[2])\n            return dict(cached_posts=zip(cached_posts,post_uid,post_created_on))\n    except:\n        list = "Oops !! It seems that our Redis cluster is down. But fear nothing, a team of trained monkeys were dispatched to fix it !!!"\n        return dict(list=list)\n\n@auth.requires_login()\ndef search():\n    import urllib2, traceback\n    from tweet_tasks import search_tweet\n    if request.vars[\'q\']:\n        try:\n            query = urllib2.quote(request.vars[\'q\'])\n            result = search_tweet.delay(query)\n            list = result.get()\n            return list\n        except:\n            return traceback.format_exc()\n    else:\n        query=[]\n        list = dict(post=query)\n        return list\n\n\n@auth.requires_login()\ndef user_directory():\n    import memcache\n    users=db(db.auth_user.id!=auth.user_id).select()\n    mc = memcache.Client([\'localhost:11211\'], debug=1)\n    following=mc.get(\'following_%s\' %auth.user_id)\n    if not following:\n        following=[f.following for f in db(db.follow.follower==auth.user_id).select(db.follow.following)]\n        mc.set(\'following_%s\' %auth.user_id, following)\n    return dict(users=users,following=following)\n\n@auth.requires_login()\ndef follow():\n    from tweet_tasks import do_follow\n    user_id=request.args(0)\n    do_follow.delay(int(auth.user_id),int(user_id))\n    return\n\n@auth.requires_login()\ndef unfollow():\n    from tweet_tasks import do_unfollow\n    user_id=request.args(0)\n    do_unfollow.delay(int(auth.user_id),int(user_id))\n    return\n\ndef user():\n    """\n    exposes:\n    http://..../[app]/default/user/login\n    http://..../[app]/default/user/logout\n    http://..../[app]/default/user/register\n    http://..../[app]/default/user/profile\n    http://..../[app]/default/user/retrieve_password\n    http://..../[app]/default/user/change_password\n    http://..../[app]/default/user/manage_users (requires membership in\n    use @auth.requires_login()\n        @auth.requires_membership(\'group name\')\n        @auth.requires_permission(\'read\',\'table name\',record_id)\n    to decorate functions that need access control\n    """\n    return dict(form=auth())\n\n\n@cache.action()\ndef download():\n    """\n    allows downloading of uploaded files\n    http://..../[app]/default/download/[filename]\n    """\n    return response.download(request, db)\n\n\ndef call():\n    """\n    exposes services. for example:\n    http://..../[app]/default/call/jsonrpc\n    decorate with @services.jsonrpc the functions to expose\n    supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv\n    """\n    return service()\n\n\n@auth.requires_login() \ndef api():\n    """\n    this is example of API with access control\n    WEB2PY provides Hypermedia API (Collection+JSON) Experimental\n    """\n    from gluon.contrib.hypermedia import Collection\n    rules = {\n        \'<tablename>\': {\'GET\':{},\'POST\':{},\'PUT\':{},\'DELETE\':{}},\n        }\n    return Collection(db).process(request,response,rules)\n\nresponse._vars=response._caller(post)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/var/www/web2py/gluon/restricted.py", line 224, in restricted\n    exec ccode in environment\n  File "/var/www/web2py/applications/twitkiller/controllers/default.py", line 169, in <module>\n  File "/var/www/web2py/gluon/globals.py", line 393, in <lambda>\n    self._caller = lambda f: f()\n  File "/var/www/web2py/gluon/tools.py", line 3444, in f\n    return action(*a, **b)\n  File "/var/www/web2py/applications/twitkiller/controllers/default.py", line 33, in post\n    save_post.delay(form.vars.tweet_id,form.vars.user_id,form.vars.post,form.vars.created_on)\n  File "/usr/lib/python2.6/site-packages/celery/app/task.py", line 453, in delay\n    return self.apply_async(args, kwargs)\n  File "/usr/lib/python2.6/site-packages/celery/app/task.py", line 555, in apply_async\n    **dict(self._get_exec_options(), **options)\n  File "/usr/lib/python2.6/site-packages/celery/app/base.py", line 353, in send_task\n    reply_to=reply_to or self.oid, **options\n  File "/usr/lib/python2.6/site-packages/celery/app/amqp.py", line 305, in publish_task\n    **kwargs\n  File "/usr/lib/python2.6/site-packages/kombu/messaging.py", line 168, in publish\n    routing_key, mandatory, immediate, exchange, declare)\n  File "/usr/lib/python2.6/site-packages/kombu/connection.py", line 457, in _ensured\n    interval_max)\n  File "/usr/lib/python2.6/site-packages/kombu/connection.py", line 369, in ensure_connection\n    interval_start, interval_step, interval_max, callback)\n  File "/usr/lib/python2.6/site-packages/kombu/utils/__init__.py", line 243, in retry_over_time\n    return fun(*args, **kwargs)\n  File "/usr/lib/python2.6/site-packages/kombu/connection.py", line 237, in connect\n    return self.connection\n  File "/usr/lib/python2.6/site-packages/kombu/connection.py", line 741, in connection\n    self._connection = self._establish_connection()\n  File "/usr/lib/python2.6/site-packages/kombu/connection.py", line 696, in _establish_connection\n    conn = self.transport.establish_connection()\n  File "/usr/lib/python2.6/site-packages/kombu/transport/pyamqp.py", line 112, in establish_connection\n    conn = self.Connection(**opts)\n  File "/usr/lib/python2.6/site-packages/amqp/connection.py", line 165, in __init__\n    self.transport = self.Transport(host, connect_timeout, ssl)\n  File "/usr/lib/python2.6/site-packages/amqp/connection.py", line 186, in Transport\n    return create_transport(host, connect_timeout, ssl)\n  File "/usr/lib/python2.6/site-packages/amqp/transport.py", line 299, in create_transport\n    return TCPTransport(host, connect_timeout)\n  File "/usr/lib/python2.6/site-packages/amqp/transport.py", line 95, in __init__\n    raise socket.error(last_err)\nerror: [Errno 111] Connection refused\n'
p11
s.